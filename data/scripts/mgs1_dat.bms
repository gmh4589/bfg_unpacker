# Metal Gear Solid (PS1)

quickbmsver "0.8.5"

get archive_name basename
get archive_ext extension
get fullsize asize

if archive_name == "demo" || archive_name == "vox"
	set vpx 1
	for y = 0
		log MEMORY_FILE 0 0
		append
		do
			savepos offset2
			get dt1 byte
			get dt2 threebyte
			if dt1 != 0
				if dt1 != 0xf0
					log MEMORY_FILE offset2 dt2
				else
					log MEMORY_FILE offset2 dt2
					break
				endif
			else
				break
			endif
			math offset2 += dt2
			goto offset2
		while dt1 != 0
		append
		get fsize asize MEMORY_FILE
		if archive_name == "demo"
			string name p= "%s_%08d.dmo" archive_name vpx
		elif archive_name == "vox"
			string name p= "%s_%08d.vox" archive_name vpx
		endif
		if fsize != 0
			log name 0 fsize MEMORY_FILE
		endif
		math vpx += 1
	next y
elif archive_name & "stage"
	math filenum = 0
	get header_size long
	xmath entries "header_size / 12"
	for stg = 0 < entries
		getdstring stage_name 8
		get stage_offset long
		math stage_offset * 0x800
		
		savepos tmp1
		goto stage_offset
		get base_number short
		get stage_size short
		math base_number * 0x800
		math stage_size * base_number
		goto tmp1
		
		/*
		string stage_manifest p "stage/%s.txt" stage_name
		open fdse stage_manifest 1 exists
		
		if exists == 1
			get manifest_textsize asize 1
			for m1 = 0
				set base_string string ""
				savepos manifest_textoff 1
				get manifest_name line 1
				set base_string string manifest_name
				callfunction hash_name 1
				putarray 1 m1 result
				putarray 2 m1 manifest_name
				math m1 + 1
			next m1
		endif
		*/
		log MEMORY_FILE stage_offset stage_size
		math filenum = -1
		
		get stage01 short MEMORY_FILE
		get stage02 short MEMORY_FILE
		xmath stage03 "stage02 * (stage01 * 0x800)"
		math stage04 == 0x800
		math parse_d = 0
		do
			math stage_file_offset = stage04
			get stage_c01 short MEMORY_FILE
			get stage_c02 byte MEMORY_FILE
			get extension_letter byte MEMORY_FILE
			get stage_c04 long MEMORY_FILE
			savepos stage_t01 MEMORY_FILE
			
			if stage_c02 == 0x63
				string stage_d01 p "%s/cache/" stage_name
			elif stage_c02 == 0x6e
				string stage_d01 p "%s/nocache/" stage_name
			elif stage_c02 == 0x72
				string stage_d01 p "%s/resident/" stage_name
			elif stage_c02 == 0x73
				if extension_letter == 0x65 | extension_letter == 0x6d | extension_letter == 0x77
					string stage_d01 p "%s/sound/" stage_name
				else
					string stage_d01 p "%s/s/" stage_name
				endif
			else
				string stage_d01 p "%s/" stage_name
			endif
			
			callfunction assign_extension 1
			
			if parse_d = 0
				
				if stage_c01 == result
					set stage_c05 string stage_name
					string stage_d02 p "%s.%s" stage_c05 stage_file_extension
				else
					string stage_d02 p "%04x.%s" stage_c01 stage_file_extension
				endif
				
				string stage_d01 + stage_d02
				
				if stage_c02 == 0x63
					xmath stage_t02 "stage_t01 + 4"
					goto stage_t02 MEMORY_FILE
					get stage_t03 long MEMORY_FILE
					goto stage_t01 MEMORY_FILE
					xmath stage_t04 "stage_t03 - stage_c04"
					
					if extension_letter != 0xff
						math stage04 += stage_t04
					else
						math stage04 x 0x800
					endif
				else
					math stage04 += stage_c04
					math stage04 x 0x800
				endif
				
				set stage_file_name string stage_d01
				if stage_c02 == 0x63
					math stage_file_size = stage_t04
				else
					math stage_file_size = stage_c04
				endif
			elif parse_d = 1
				log MEMORY_FILE2 stage04 stage_c04 MEMORY_FILE
				math filenum = -2
				savepos d_pos MEMORY_FILE2
				for
					if d_pos >= stage_c04
						break
					endif
					goto d_pos MEMORY_FILE2
					get d_fhash short MEMORY_FILE2
					get extension_letter byte MEMORY_FILE2
					get d_f03 byte MEMORY_FILE2
					get d_fsize long MEMORY_FILE2
					savepos d_pos MEMORY_FILE2
					callfunction assign_extension 1
					string stage_d02 p "%04x.%s" d_fhash stage_file_extension
					string stage_d_file_name p "%s%s" stage_d01 stage_d02
					log stage_d_file_name d_pos d_fsize MEMORY_FILE2
					math d_pos + d_fsize
				next
				
				math stage04 += stage_c04
				math stage04 x 0x800
			endif
			
			if extension_letter != 0xff
				if parse_d == 0
				if stage_file_size != 0
					log stage_file_name stage_file_offset stage_file_size MEMORY_FILE
				endif
				endif
			endif
			
			math parse_d = 0
		while stage_c01 != 0 || stage_c04 != 0
	next stg
else
	print "%ARCHIVE_NAME%.%ARCHIVE_EXT% isn`t supported with this script. Contact me."
	cleanexit
endif

startfunction assign_extension
	if filenum = -1
		goto stage04 filenum
	elif filenum = -2
		goto stage_t01 filenum
	endif
	
	if extension_letter == 0x61
		set stage_file_extension string "a"
		# aar, azm
	elif extension_letter == 0x62
		set stage_file_extension string "bin"
	elif extension_letter == 0x63
		set stage_file_extension string "con"
	elif extension_letter == 0x64
		# these "dar" files you see on the PC version of the game are actually parsed
		# within the STAGE.DIR file on the PS1 version of the game, hence no extraction as its own file
		math parse_d = 1
	elif extension_letter == 0x65
		set stage_file_extension string "efx"
	elif extension_letter == 0x67
		set stage_file_extension string "gcx"
		# or gcl
	elif extension_letter == 0x68
		set stage_file_extension string "hzm"
		# or hzd
	elif extension_letter == 0x69
		set stage_file_extension string "img"
	elif extension_letter == 0x6b
		set stage_file_extension string "kmd"
	elif extension_letter == 0x6c
		set stage_file_extension string "lit"
	elif extension_letter == 0x6d
		if stage_c02 == 0x73
			set stage_file_extension string "mdx"
		else
			set stage_file_extension string "mt3"
		endif
	elif extension_letter == 0x6f
		set stage_file_extension string "oar"
	elif extension_letter == 0x70
		set stage_file_extension string "p"
		# pcc, pcx
	elif extension_letter == 0x71
		set stage_file_extension string "q"
	elif extension_letter == 0x72
		/*
		if filenum = -1
			goto stage04 filenum
		endif
		get r01 byte filenum
		get r02 byte filenum
		get r03 byte filenum
		get r04 byte filenum
		get r05 byte filenum
		get r06 byte filenum
		if filenum = -1
			goto stage_t01 filenum
		endif
		if r01 == 0x09
		if r02 == 0x28
		if r03 == 0x00
		if r04 == 0x00
			set stage_file_extension string "rpk"
		endif
		endif
		endif
		else
		if r02 == 0x00
		if r03 == 0x00
		if r04 == 0x00
		if r05 == 0x20 | r05 == 0x40
		if r06 == 0x01
			set stage_file_extension string "rar"
		endif
		endif
		endif
		endif
		else
			set stage_file_extension string "res"
		endif
		endif
		*/
		set stage_file_extension string "r"
		# rar, res, rpk
	elif extension_letter == 0x73
		set stage_file_extension string "sgt"
	elif extension_letter == 0x77
		set stage_file_extension string "wvx"
	elif extension_letter == 0x7a
		set stage_file_extension string "zmd"
	else
		set stage_file_extension string ""
	endif
	
	if filenum = -1
		goto stage_t01 filenum
	elif filenum = -2
		goto d_pos filenum
	endif
endfunction

startfunction hash_name
	strlen name_size base_string
	math hash = 0
	math result = 0
	
	for x1 = 0 < name_size
		getvarchr string_char base_string x1 byte
		putarray 11 x1 string_char
	next x1
	
	for x2 = 0 < name_size
		getarray string_char 11 x2
		xmath hash "(((hash << 5) | (hash >> 11)) + string_char) & 0xffff"
		putarray 12 x2 hash
	next x2
	
	xmath result "hash & 0xffff"
endfunction
