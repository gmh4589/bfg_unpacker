# MODULE.IPK (MGS2, AZOE/ZOE2, MGS3)
# inspired by Nisto's efforts at decrypting the file(https://github.com/Nisto/zoe2_ipk_dec),
# i had to hit up my IDA Pro copy[1] just to load PLD.IRX in it just to see if his code was correct at the very least
# then i decided to do this
# ---
# [1] a "cracked" copy of it, that is. what do you expect me to do mate? shell out for a legit copy of it since it's not meant for personal use anyway?

open FDSE "MODULE.IPK"

get ipk_size asize

math ipk_offset == 0
for
	goto ipk_offset
	if ipk_offset >= ipk_size
		break
	endif
	
	math ipk_number1 == 0xA84E6B2E
	math ipk_number2 == 0x7E8A6B4C
	for x = 0 < 4
		get ipk_byte01 long
		callfunction decrypt_ipk 1
		if x = 0
			math ipk_block_size == ipk_decbyte
		elif x = 1
			math ipk_file_size == ipk_decbyte
		elif x = 2
			math ipk_name_size == ipk_decbyte
		elif x = 3
			math ipk_zero == ipk_decbyte
		endif
	next x
	
	if ipk_block_size != 0
		putvarchr MEMORY_FILE ipk_block_size 0
		log MEMORY_FILE 0 0
		xmath ipk_file_chunks "ipk_block_size / 4"
		for v1 = 0 < ipk_file_chunks
			xmath v2 "v1 * 4"
			get ipk_byte01 long
			callfunction decrypt_ipk 1
			putvarchr MEMORY_FILE v2 ipk_decbyte long
		next v1
		goto ipk_file_size MEMORY_FILE
		getdstring ipk_file_name ipk_name_size MEMORY_FILE
		log ipk_file_name 0 ipk_file_size MEMORY_FILE
	endif
	math ipk_offset += ipk_block_size
	math ipk_offset += 0x10
next

startfunction decrypt_ipk
	xmath ipk_decbyte "ipk_byte01 ^ ipk_number2"
	math ipk_number2 += ipk_number1
endfunction
